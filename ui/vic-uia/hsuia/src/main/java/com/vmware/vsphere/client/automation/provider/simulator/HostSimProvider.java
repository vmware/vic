/* Copyright 2014 VMware, Inc. All rights reserved. -- VMware Confidential */
package com.vmware.vsphere.client.automation.provider.simulator;

import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vmware.client.automation.common.spec.ServiceSpec;
import com.vmware.client.automation.connector.TestbedConnector;
import com.vmware.client.automation.workflow.explorer.SettingsReader;
import com.vmware.client.automation.workflow.explorer.SettingsUtil;
import com.vmware.client.automation.workflow.explorer.SettingsWriter;
import com.vmware.client.automation.workflow.provider.AssemblerSpec;
import com.vmware.client.automation.workflow.provider.BaseElementalProvider;
import com.vmware.client.automation.workflow.provider.ProviderWorkflow;
import com.vmware.client.automation.workflow.provider.PublisherSpec;
import com.vmware.vsphere.client.automation.provider.simulator.connector.SimulatorConnectorsFactory;
import com.vmware.vsphere.client.automation.provider.simulator.spec.SimulatorHostSpec;
import com.vmware.vsphere.client.automation.provider.simulator.spec.SimulatorServiceSpec;
import com.vmware.vsphere.client.automation.provider.simulator.util.SimulatorUtil;

/**
 * The provider simulates provisioning of an ESXi host. While no actual
 * provisioning is made, it reproduces logically accurate the experience from a
 * real provider.
 *
 * Concrete session settings are consumed to indetify the simulator's type and
 * randomly generated output test bed settings are stored once the deployment is
 * complete. These settings cannot be consumed by actual test bed.
 *
 * Some random results might be generated by setting the session's
 * allowRandomFailure control parameter to true. Some phase in the lifecycle
 * will start failing on random bases. The provisioning system tries to recover
 * from the errors cleanly, which could be used for testing the reliability
 * tunings of the system.
 *
 * You may use this simulator to explore the scalability limits of the
 * provisioning system by producing very large volume of test bed artifacts
 * without actually consuming resources.
 *
 * REF
 */
public class HostSimProvider extends BaseElementalProvider {

   private static final Logger _logger = LoggerFactory.getLogger(HostSimProvider.class);

   public static final String DEFAULT_ENTITY = "provider.simulator.host.entity.default";

   private static final String TESTBED_KEY_ENDPOINT = "testbed.endpoint";
   private static final String TESTBED_KEY_USERNAME = "testbed.user";
   private static final String TESTBED_KEY_PASSWORD = "testbed.pass";

   private static final String RESOURCE_KEY_PRODUCT = "resource.simulatedhost.product";
   private static final String RESOURCE_KEY_BRANCH = "resource.simulatedhost.branch";
   private static final String RESOURCE_KEY_BUILDNUM = "resource.simulatedhost.buildNumber";

   private static final String CONTROL_KEY_RNDFAILURE = "control.simulator.allowRandomFailure";

   private String _product;
   private String _branch;
   private String _buildNumber;
   private boolean _allowRandomFailure;

   @Override
   public void initPublisherSpec(PublisherSpec publsherSpec) throws Exception {

      SimulatorHostSpec simulatorHostSpec = new SimulatorHostSpec();
      publsherSpec.links.add(simulatorHostSpec);
      publsherSpec.publishEntitySpec(DEFAULT_ENTITY, simulatorHostSpec);
   }

   @Override
   public void assignTestbedSettings(PublisherSpec publisherSpec,
         SettingsReader testbedSettings) throws Exception {

      SimulatorHostSpec simulatorHostSpec = publisherSpec.links
            .get(SimulatorHostSpec.class);

      String endpoint = SettingsUtil.getRequiredValue(testbedSettings,
            TESTBED_KEY_ENDPOINT);
      String username = SettingsUtil.getRequiredValue(testbedSettings,
            TESTBED_KEY_USERNAME);
      String password = SettingsUtil.getRequiredValue(testbedSettings,
            TESTBED_KEY_PASSWORD);

      simulatorHostSpec.service.set(new SimulatorServiceSpec());

      simulatorHostSpec.service.get().endpoint.set(endpoint);
      simulatorHostSpec.service.get().username.set(username);
      simulatorHostSpec.service.get().password.set(password);

      simulatorHostSpec.name.set(endpoint);
   }

   @Override
   public void assignTestbedConnectors(
         Map<ServiceSpec, TestbedConnector> serviceConnectorsMap) {
      SimulatorConnectorsFactory.createAndSetConnectors(serviceConnectorsMap);
   }

   @Override
   public void prepareForOperations(PublisherSpec filteredPublisherSpecSpec,
         AssemblerSpec filteredAssemblerSpec, boolean isAssembling,
         SettingsReader sessionSettingsReader) {

      _product = SettingsUtil.getRequiredValue(sessionSettingsReader,
            RESOURCE_KEY_PRODUCT);
      _branch = SettingsUtil.getRequiredValue(sessionSettingsReader,
            RESOURCE_KEY_BRANCH);
      _buildNumber = SettingsUtil.getRequiredValue(sessionSettingsReader,
            RESOURCE_KEY_BUILDNUM);

      _allowRandomFailure = SettingsUtil.getBooleanValue(sessionSettingsReader,
            CONTROL_KEY_RNDFAILURE);
   }

   @Override
   public String determineResourceVersion() throws Exception {
      // Version product-branch-buildnumber
      return String.format("%s-%s-%s", _product, _branch, _buildNumber);
   }

   @Override
   public void retrieveResource() throws Exception {
      _logger.info("Simulating resource retieval by waiting a second...");

      Thread.sleep(1000);

      SimulatorUtil.trySucceed(_allowRandomFailure);
   }

   @Override
   public void deployTestbed(SettingsWriter testbedSettingsWriter)
         throws Exception {

      _logger.info("Simulating deployment by waiting a second...");

      Thread.sleep(1000);

      SimulatorUtil.trySucceed(_allowRandomFailure);

      _logger.info("Saving test bed connection data...");

      testbedSettingsWriter.setSetting(TESTBED_KEY_ENDPOINT,
            SimulatorUtil.getRandomString());
      testbedSettingsWriter.setSetting(TESTBED_KEY_USERNAME,
            SimulatorUtil.getRandomString());
      testbedSettingsWriter.setSetting(TESTBED_KEY_PASSWORD,
            SimulatorUtil.getRandomString());
   }

   @Override
   public boolean checkTestbedHealth() throws Exception {
      _logger.info("Simulating health checking by waiting a second...");

      Thread.sleep(1000);

      try {
         SimulatorUtil.trySucceed(_allowRandomFailure);
      } catch (Exception e) {
         return false;
      }
      return true;
   }

   @Override
   public void destroyTestbed() throws Exception {
      _logger.info("Simulating test bed destruction by waiting a second...");

      Thread.sleep(1000);

      SimulatorUtil.trySucceed(_allowRandomFailure);
   }

   @Override
   public void assignTestbedSettings(AssemblerSpec assemblerSpec,
         SettingsReader testbedSettings) throws Exception {
      // TODO Auto-generated method stub

   }

   @Override
   public int providerWeight() {
      return 1;
   }

   @Override
   public Class<? extends ProviderWorkflow> getProviderBaseType() {
      return this.getClass();
   }
}
