// Copyright 2017 VMware, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Automatically generated by MockGen. DO NOT EDIT!
// Source: github.com/vmware/vic/lib/tether-ng (interfaces: Plugin,Tetherer)

package mock_tether_ng

import (
	context "context"

	gomock "github.com/golang/mock/gomock"
	uuid "github.com/google/uuid"
	tether_ng "github.com/vmware/vic/lib/tether-ng"
	types "github.com/vmware/vic/lib/tether-ng/types"
)

// Mock of Plugin interface
type MockPlugin struct {
	ctrl     *gomock.Controller
	recorder *_MockPluginRecorder
}

// Recorder for MockPlugin (not exported)
type _MockPluginRecorder struct {
	mock *MockPlugin
}

func NewMockPlugin(ctrl *gomock.Controller) *MockPlugin {
	mock := &MockPlugin{ctrl: ctrl}
	mock.recorder = &_MockPluginRecorder{mock}
	return mock
}

func (_m *MockPlugin) EXPECT() *_MockPluginRecorder {
	return _m.recorder
}

func (_m *MockPlugin) Configure(_param0 context.Context, _param1 *types.ExecutorConfig) error {
	ret := _m.ctrl.Call(_m, "Configure", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockPluginRecorder) Configure(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Configure", arg0, arg1)
}

func (_m *MockPlugin) Start(_param0 context.Context) error {
	ret := _m.ctrl.Call(_m, "Start", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockPluginRecorder) Start(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Start", arg0)
}

func (_m *MockPlugin) Stop(_param0 context.Context) error {
	ret := _m.ctrl.Call(_m, "Stop", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockPluginRecorder) Stop(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Stop", arg0)
}

func (_m *MockPlugin) UUID(_param0 context.Context) uuid.UUID {
	ret := _m.ctrl.Call(_m, "UUID", _param0)
	ret0, _ := ret[0].(uuid.UUID)
	return ret0
}

func (_mr *_MockPluginRecorder) UUID(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "UUID", arg0)
}

// Mock of Tetherer interface
type MockTetherer struct {
	ctrl     *gomock.Controller
	recorder *_MockTethererRecorder
}

// Recorder for MockTetherer (not exported)
type _MockTethererRecorder struct {
	mock *MockTetherer
}

func NewMockTetherer(ctrl *gomock.Controller) *MockTetherer {
	mock := &MockTetherer{ctrl: ctrl}
	mock.recorder = &_MockTethererRecorder{mock}
	return mock
}

func (_m *MockTetherer) EXPECT() *_MockTethererRecorder {
	return _m.recorder
}

func (_m *MockTetherer) Plugins(_param0 context.Context) []tether_ng.Plugin {
	ret := _m.ctrl.Call(_m, "Plugins", _param0)
	ret0, _ := ret[0].([]tether_ng.Plugin)
	return ret0
}

func (_mr *_MockTethererRecorder) Plugins(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Plugins", arg0)
}

func (_m *MockTetherer) Register(_param0 context.Context, _param1 tether_ng.Plugin) error {
	ret := _m.ctrl.Call(_m, "Register", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTethererRecorder) Register(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Register", arg0, arg1)
}

func (_m *MockTetherer) Unregister(_param0 context.Context, _param1 tether_ng.Plugin) error {
	ret := _m.ctrl.Call(_m, "Unregister", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTethererRecorder) Unregister(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Unregister", arg0, arg1)
}
