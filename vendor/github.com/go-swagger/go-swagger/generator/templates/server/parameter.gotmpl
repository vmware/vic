{{ define "sliceparamvalidator"}}
{{ if .NeedsSize }}
{{ camelize .Name }}Size := int64(len({{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{ .ValueExpression }}))
{{ end }}
{{ if .MinItems }}
if err := validate.MinItems({{ .Path }}, {{ printf "%q" .Location }}, {{ camelize .Name }}Size, {{ .MinItems }}); err != nil {
  return err
}
{{ end }}
{{ if .MaxItems }}
if err := validate.MaxItems({{ .Path }}, {{ printf "%q" .Location }}, {{ camelize .Name }}Size, {{.MaxItems}}); err != nil {
  return err
}
{{ end }}
{{ if .UniqueItems }}
if err := validate.UniqueItems({{ .Path }}, {{ printf "%q" .Location }}, {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{ .ValueExpression }}); err != nil {
  return err
}
{{ end }}
{{ if .Enum }}
if err := validate.Enum({{ .Path }}, {{ printf "%q" .Location }}, {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{ .ValueExpression }}, {{ .Enum }}); err != nil {
  return err
}
{{ end }}
{{ end }}{{ define "propertyparamvalidator" }}
{{ if .IsPrimitive }}{{ template "validationPrimitive" . }}{{ end }}
{{ if .IsCustomFormatter }}
if err := validate.FormatOf({{.Path}}, "{{.Location}}", "{{.SwaggerFormat}}", string({{.ValueExpression}}), formats); err != nil {
  return err
}{{ end }}
{{ if .IsArray }}{{ template "sliceparamvalidator" . }}{{ end }}
{{ end }}{{define "bindprimitiveparam" }}
{{ end }}{{define "sliceparambinder" }}
{{ if .Parent }}{{ .IndexVar }}c := swag.SplitByFormat({{ .Parent.IndexVar }}c[{{ .Parent.IndexVar }}], {{ printf "%q" .CollectionFormat }})
{{ else }}{{ .IndexVar }}c := raw{{ end }}
{{ .IndexVar }}sz := size
var {{ .IndexVar }}r {{ .GoType }}
{{ .IndexVar }}ValidateElement := func({{ .IndexVar }} int, {{ camelize .Child.Name }} {{ .Child.GoType }}) *errors.Validation {
  {{ template "propertyparamvalidator" .Child }}
  return nil
}

for {{ .IndexVar }} := 0; {{ .IndexVar }} < {{ .IndexVar }}sz; {{ .IndexVar }}++ {
  {{ if or .Child.IsCustomFormatter .Child.IsPrimitive }}{{ if .Child.Converter }}value, err := {{ .Child.Converter }}({{ .IndexVar }}c[{{ .IndexVar }}])
  if err != nil {
    return errors.InvalidType({{ .Child.Path }}, {{ printf "%q" .Location }}, "{{ .Child.GoType }}", {{ .IndexVar }}c[{{ .IndexVar }}])
  }

  if err := {{ .IndexVar }}ValidateElement({{ .IndexVar }}, {{ if .Child.Converter }}value{{ else }}{{ .Child.ValueExpression }}{{ end }}); err != nil {
    return err
  }
  {{ .IndexVar }}r = append({{ .IndexVar }}r, value)
  {{else}}
    if err := {{ .IndexVar }}ValidateElement({{ .IndexVar }}, {{ .IndexVar }}c[{{ .IndexVar }}]); err != nil {
      return err
    }
  {{ .IndexVar }}r = append({{ .IndexVar }}r, {{ .IndexVar }}c[{{ .IndexVar }}]){{ end }}{{ else if .Child.IsArray }}
  {{ template "sliceparambinder" .Child }}
    if err := {{ .IndexVar }}ValidateElement({{ .IndexVar }}, {{ .Child.IndexVar }}r); err != nil {
      return err
    }
  {{ .IndexVar }}r = append({{ .IndexVar }}r, {{ .Child.IndexVar }}r){{ end }}
}
{{ end }}package {{ .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "net/http"

  "github.com/go-swagger/go-swagger/errors"
  "github.com/go-swagger/go-swagger/httpkit/validate"
  "github.com/go-swagger/go-swagger/httpkit"
  "github.com/go-swagger/go-swagger/swag"

  strfmt "github.com/go-swagger/go-swagger/strfmt"

  {{ range .DefaultImports }}{{ printf "%q" .}}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)

// New{{ pascalize .Name }}Params creates a new {{ pascalize .Name }}Params object
// with the default values initialized.
func New{{ pascalize .Name }}Params() {{ pascalize .Name }}Params {
  var (
  {{ range .Params }}{{ if .HasDefault }}{{ if not .IsFileParam }}{{ camelize .Name}}Default {{ .GoType }} = {{ if .IsPrimitive}}{{.GoType}}({{ end}}{{ printf "%#v" .Default }}{{ if .IsPrimitive }}){{ end }}
  {{ end }}{{ end }}{{end}}
  )
  return {{ pascalize .Name }}Params{ {{ range .Params }}{{ if .HasDefault }}
    {{ pascalize .Name}}: {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}&{{ end }}{{ camelize .Name }}Default,
  {{ end }}{{ end }} }
}

// {{ pascalize .Name }}Params contains all the bound params for the {{ humanize .Name }} operation
// typically these are obtained from a http.Request
//
// swagger:parameters {{ .Name }}
type {{ pascalize .Name }}Params struct {
  {{ range .Params }}/*{{ if .Description }}{{ .Description }}{{ end }}{{ if .Required }}
  Required: true{{ end }}{{ if .Maximum }}
  Maximum: {{ if .ExclusiveMaximum }}< {{ end }}{{ .Maximum }}{{ end }}{{ if .Minimum }}
  Minimum: {{ if .ExclusiveMinimum }}> {{ end }}{{ .Minimum }}{{ end }}{{ if .MultipleOf }}
  Multiple Of: {{ .MultipleOf }}{{ end }}{{ if .MaxLength }}
  Max Length: {{ .MaxLength }}{{ end }}{{ if .MinLength }}
  Min Length: {{ .MinLength }}{{ end }}{{ if .Pattern }}
  Pattern: {{ .Pattern }}{{ end }}{{ if .MaxItems }}
  Max Items: {{ .MaxItems }}{{ end }}{{ if .MinItems }}
  Min Items: {{ .MinItems }}{{ end }}{{ if .UniqueItems }}
  Unique: true{{ end }}{{ if .Location }}
  In: {{ .Location }}{{ end }}{{ if .CollectionFormat }}
  Collection Format: {{ .CollectionFormat }}{{ end }}{{ if .HasDefault }}
  Default: {{ printf "%#v" .Default }}{{ end }}
  */
  {{ if not .Schema }}{{ pascalize .Name }} {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsFileParam) (not .IsStream) .IsNullable }}*{{ end }}{{.GoType}}{{ else }}{{ pascalize .Name }} {{ if and (not .Schema.IsBaseType) .IsNullable (not .Schema.IsStream) }}*{{ end }}{{.GoType}}{{ end }}
  {{ end}}
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
  var res []error
  {{ if .HasQueryParams }}qs := httpkit.Values(r.URL.Query())
  {{ else if .HasFormParams }}if err := r.ParseMultipartForm(32 << 20); err != nil {
		if err != http.ErrNotMultipart {
            return err
        } else if err := r.ParseForm(); err != nil {
            return err
        }
	}
	fds := httpkit.Values(r.Form)
  {{ end }}

  {{ range .Params }}
  {{ if not .IsArray }}{{ if .IsQueryParam }}q{{ pascalize .Name }}, qhk{{ pascalize .Name }}, _ := qs.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(q{{ pascalize .Name }}, qhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsPathParam }}r{{ pascalize .Name }}, rhk{{ pascalize .Name }}, _ := route.Params.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(r{{ pascalize .Name }}, rhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsHeaderParam }}if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(r.Header[{{ .Path }}], true, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsFormParam }}{{if .IsFileParam }}{{ camelize .Name }}, {{ camelize .Name }}Header, err := r.FormFile({{ .Path }})
  if err != nil {
    res = append(res, errors.New(400, "reading file %q failed: %v", {{ printf "%q" (camelize .Name) }}, err))
  } else {
    {{ .ReceiverName }}.{{ pascalize .Name }} = httpkit.File{Data: {{ camelize .Name }}, Header: {{ camelize .Name }}Header}
  }
  {{ else }}fd{{ pascalize .Name }}, fdhk{{ pascalize .Name }}, _ := fds.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(fd{{ pascalize .Name }}, fdhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ end }}{{ end }}
  {{ else if .IsArray }}{{ if .IsQueryParam }}q{{ pascalize .Name }}, qhk{{ pascalize .Name }}, _ := qs.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(q{{ pascalize .Name }}, qhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if and .IsFormParam }}fd{{ pascalize .Name }}, fdhk{{ pascalize .Name }}, _ := fds.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(fd{{ pascalize .Name }}, fdhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ end }}{{ end }}

  {{ if and .IsBodyParam .Schema }}{{ if .Schema.IsStream }}
  {{ .ReceiverName }}.{{ pascalize .Name }} = r.Body
  {{ else }}defer r.Body.Close()
  {{ if and .Schema.IsBaseType .Schema.IsExported }}body, err := {{ .ModelsPackage }}.Unmarshal{{ stripPackage .GoType .ModelsPackage }}{{ if .IsArray }}Slice{{ end }}(r.Body, route.Consumer)
  if err != nil { {{ if .Required }}
    if err == io.EOF {
      err = errors.Required({{ .Path }}, {{ printf "%q" .Location }})
    }
    {{ end }}res = append(res, err)
  {{ else }}var body {{ .GoType }}
  if err := route.Consumer.Consume(r.Body, &body); err != nil { {{ if .Required }}
    if err == io.EOF {
      res = append(res, errors.Required({{ printf "%q" (camelize .Name) }}, {{ printf "%q" .Location }}))
    } else { {{ end }}
    res = append(res, errors.NewParseError({{ printf "%q" (camelize .Name) }}, {{ printf "%q" .Location }}, "", err)){{ if .Required }}
    }
    {{ end }}
  {{ end }}} else {
    {{ if .IsArray }}{{ if .Child }}{{ if (and (not .Schema.IsInterface) (or .Child.IsAliased .Child.IsComplexObject)) }}for _, {{ .IndexVar }}{{ .ReceiverName }} := range {{ .ReceiverName }}.{{ pascalize .Name }} {
      if err := {{ .IndexVar }}{{ .ReceiverName }}.Validate(route.Formats); err != nil {
        res = append(res, err)
        break
      }
    }
    {{ end }}{{ end }}{{ else if (and (not .Schema.IsInterface) (or .Schema.IsAliased .Schema.IsComplexObject)) }}if err := body.Validate(route.Formats); err != nil {
      res = append(res, err)
    }
    {{ end }}
    if len(res) == 0 {
      {{ .ReceiverName }}.{{ pascalize .Name }} = {{ if and (not .Schema.IsBaseType) .IsNullable }}&{{ end }}body
    }
  }
  {{ end }}
  {{ end }}
  {{ end }}
  if len(res) > 0 {
    return errors.CompositeValidationError(res...)
  }
  return nil
}

{{ $className := (pascalize .Name) }}
{{ range .Params }}
{{ if not (or .IsBodyParam .IsFileParam) }}
{{ if or .IsPrimitive .IsCustomFormatter }}
func ({{ .ReceiverName }} *{{ $className }}Params) bind{{ pascalize .Name }}(rawData []string, hasKey bool, formats strfmt.Registry) error {
  {{ if and (not .IsPathParam) .Required }}if !hasKey {
    return errors.Required({{ .Path }}, {{ printf "%q" .Location }})
  }
  {{ end }}var raw string
  if len(rawData) > 0 {
    raw = rawData[len(rawData)-1]
  }
  {{ if and (not .IsPathParam) .Required (not .AllowEmptyValue) }}if err := validate.RequiredString({{ .Path }}, {{ printf "%q" .Location }}, raw); err != nil {
    return err
  }
  {{ else if and ( not .IsPathParam ) (or (not .Required) .AllowEmptyValue) }}if raw == "" { // empty values pass all other validations
    {{ if .HasDefault }}var {{ camelize .Name}}Default {{ if not .IsFileParam }}{{ .GoType }}{{ else }}os.File{{end}} = {{ if .IsPrimitive}}{{.GoType}}({{ end}}{{ printf "%#v" .Default }}{{ if .IsPrimitive }}){{ end }}
    {{ .ValueExpression }} = {{ if and (not .IsArray) (not .HasDiscriminator) (or .IsNullable  ) (not .IsStream) }}&{{ end }}{{ camelize .Name }}Default
    {{ end }}return nil
  }
  {{ end }}
  {{ if .Converter }}value, err := {{ .Converter }}(raw)
  if err != nil {
    return errors.InvalidType({{ .Path }}, {{ printf "%q" .Location }}, {{ printf "%q" .GoType }}, raw)
  }
  {{ .ValueExpression }} = {{ if .IsNullable }}&{{ end }}value
  {{ else if .IsCustomFormatter }}value, err := formats.Parse({{ printf "%q" .SwaggerFormat }}, raw)
  if err != nil {
    return errors.InvalidType({{ .Path }}, {{ printf "%q" .Location }}, {{ printf "%q" .GoType }}, raw)
  }
  {{ .ValueExpression }} = {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsFileParam) (not .IsStream) (not .IsNullable) }}*{{ end }}(value.(*{{ .GoType }}))
  {{else}}{{ .ValueExpression }} = {{ if .IsNullable }}&{{ end }}raw
  {{ end }}
  {{if .HasValidations }}if err := {{ .ReceiverName }}.validate{{ pascalize .Name }}(formats); err != nil {
    return err
  }
  {{ end }}
  return nil
}
{{else if .IsArray}}
func ({{ .ReceiverName }} *{{ $className }}Params) bind{{ pascalize .Name }}(rawData []string, hasKey bool, formats strfmt.Registry) error {
  {{if .Required }}if !hasKey {
    return errors.Required({{ .Path }}, {{ printf "%q" .Location }})
  }
  {{ end }}
  {{ if eq .CollectionFormat "multi" }}raw := rawData{{ else }}var qv{{ pascalize .Name }} string
  if len(rawData) > 0 {
    qv{{ pascalize .Name }} = rawData[len(rawData) - 1]
  }

  raw := swag.SplitByFormat(qv{{ pascalize .Name }}, {{ printf "%q" .CollectionFormat }}){{ end }}
  size := len(raw)
  {{if and .Required (not .AllowEmptyValue) }}
  if size == 0 {
    return errors.Required({{ .Path }}, {{ printf "%q" .Location }})
  }
  {{ end }}
  {{ if .HasDefault }}defValue := swag.SplitByFormat({{ .Default }}, {{ printf "%q" .CollectionFormat }})
  if size == 0 && len(defValue) > 0 {
    {{ .ValueExpression }} = defValue
  {{ else }}if size == 0 {
    return nil{{ end }}
  }
  {{ template "sliceparambinder" . }}
  {{ .ValueExpression }} = {{ .IndexVar }}r
  {{ if .HasSliceValidations }}if err := {{ .ReceiverName }}.validate{{ pascalize .Name }}(formats); err != nil {
    return err
  }
  {{ end }}

  return nil
}
{{ end }}
{{ if or .HasValidations .HasSliceValidations }}
func ({{ .ReceiverName }} *{{ $className }}Params) validate{{ pascalize .Name }}(formats strfmt.Registry) error {
  {{ template "propertyparamvalidator" . }}
  return nil
}
{{ end }}
{{ end }}
{{ end }}
